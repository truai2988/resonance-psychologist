<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æœ—èª­å‹•ç”»ä½œæˆãƒ„ãƒ¼ãƒ«</title>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h1 {
            color: #2c3e50;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 800px;
        }
        .controls {
            display: grid;
            gap: 15px;
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-weight: bold;
            font-size: 0.9em;
            color: #556;
        }
        input[type="text"], input[type="file"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        #preview-canvas {
            width: 100%;
            aspect-ratio: 16/9;
            background: #000;
            border-radius: 4px;
            margin-bottom: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background 0.2s;
        }
        .btn:hover {
            background-color: #2980b9;
        }
        .btn:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        .btn.recording {
            background-color: #e74c3c;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.8; }
            100% { opacity: 1; }
        }
        .status {
            margin-top: 10px;
            text-align: center;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <h1>æœ—èª­å‹•ç”»ä½œæˆãƒ„ãƒ¼ãƒ«</h1>
    <div class="container">
        <p>ç”»åƒã¨éŸ³å£°ã‚’é¸æŠã—ã¦ã€ŒéŒ²ç”»é–‹å§‹ã€ã‚’æŠ¼ã™ã¨ã€å‹•ç”»(WebMå½¢å¼)ã‚’ä½œæˆãƒ»ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã§ãã¾ã™ã€‚</p>
        
        <div class="controls">
            <div class="control-group">
                <label>1. èƒŒæ™¯ç”»åƒã‚’é¸æŠ (æ¨å¥¨: 1920x1080)</label>
                <input type="file" id="imageInput" accept="image/*">
            </div>
            
            <div class="control-group">
                <label>2. éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ (MP3/WAV)</label>
                <input type="file" id="audioInput" accept="audio/*">
            </div>

            <div class="control-group">
                <label>3. ã‚¿ã‚¤ãƒˆãƒ«ãƒ†ã‚­ã‚¹ãƒˆ (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)</label>
                <input type="text" id="titleInput" placeholder="ä¾‹: #1 ãªãœç§ãŒã‚«ã‚¦ãƒ³ã‚»ãƒ©ãƒ¼ã«ãªã£ãŸã®ã‹">
            </div>

            <div class="control-group">
                <label>ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º</label>
                <input type="range" id="fontSizeInput" min="20" max="100" value="40">
            </div>
        </div>

        <canvas id="preview-canvas" width="1920" height="1080"></canvas>

        <div style="text-align: center;">
            <button id="recordBtn" class="btn" disabled>éŒ²ç”»é–‹å§‹ (å†ç”Ÿ)</button>
        </div>
        <div id="statusText" class="status">æº–å‚™ä¸­...</div>
    </div>

    <script>
        const canvas = document.getElementById('preview-canvas');
        const ctx = canvas.getContext('2d');
        const imageInput = document.getElementById('imageInput');
        const audioInput = document.getElementById('audioInput');
        const titleInput = document.getElementById('titleInput');
        const fontSizeInput = document.getElementById('fontSizeInput');
        const recordBtn = document.getElementById('recordBtn');
        const statusText = document.getElementById('statusText');

        // State
        let images = []; // Array of Image objects
        let currentImageIndex = 0;
        let nextImageIndex = 0;
        let transitionProgress = 1; // 0 to 1
        let isTransitioning = false;
        
        let audioContext = null;
        let audioBuffer = null;
        let sourceNode = null;
        let destNode = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let audioDuration = 0;
        let animationId = null;

        // UI for Image List
        const imageListContainer = document.createElement('div');
        imageListContainer.style.marginTop = "10px";
        imageListContainer.style.display = "flex";
        imageListContainer.style.gap = "10px";
        imageListContainer.style.overflowX = "auto";
        imageInput.parentElement.appendChild(imageListContainer);

        // Helper: Add switcher instructions
        const switcherHelp = document.createElement('p');
        switcherHelp.innerText = "ğŸ’¡ éŒ²ç”»ä¸­ã«ç”»åƒã‚’ã‚¯ãƒªãƒƒã‚¯ï¼ˆã¾ãŸã¯ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ï¼‰ã™ã‚‹ã¨ã€æ¬¡ã®ç”»åƒã«ãµã‚ã£ã¨åˆ‡ã‚Šæ›¿ã‚ã‚Šã¾ã™ã€‚";
        switcherHelp.style.fontSize = "0.9em";
        switcherHelp.style.color = "#666";
        switcherHelp.style.marginTop = "5px";
        document.querySelector('.container').insertBefore(switcherHelp, recordBtn.parentElement);


        // åˆæœŸæç”»
        draw();

        imageInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            if (files.length > 0) {
                // Load all images
                let loadedCount = 0;
                images = [];
                imageListContainer.innerHTML = ''; // Clear preview

                files.forEach((file, index) => {
                    const img = new Image();
                    img.onload = () => {
                        loadedCount++;
                        if (loadedCount === files.length) {
                             // Sort images by name maybe? For now just push order
                             draw();
                             checkReady();
                        }
                    };
                    img.src = URL.createObjectURL(file);
                    images.push(img);

                    // Create thumbnail
                    const thumb = document.createElement('img');
                    thumb.src = img.src;
                    thumb.style.height = "60px";
                    thumb.style.borderRadius = "4px";
                    thumb.style.cursor = "pointer";
                    thumb.style.border = "2px solid transparent";
                    thumb.onclick = () => {
                        // If recording, specific switch? For now just preview
                        if(!isRecording) {
                            currentImageIndex = index;
                            draw();
                        }
                    };
                    imageListContainer.appendChild(thumb);
                });
                
                // Allow multiple file selection
                imageInput.setAttribute('multiple', 'true');
                currentImageIndex = 0;
            }
        });

        audioInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                statusText.innerText = "éŸ³å£°ã‚’èª­ã¿è¾¼ã¿ä¸­...";
                const arrayBuffer = await file.arrayBuffer();
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioContext.decodeAudioData(arrayBuffer, (buffer) => {
                    audioBuffer = buffer;
                    audioDuration = buffer.duration;
                    statusText.innerText = `éŸ³å£°èª­ã¿è¾¼ã¿å®Œäº†: ${Math.floor(audioDuration)}ç§’`;
                    checkReady();
                });
            }
        });

        titleInput.addEventListener('input', draw);
        fontSizeInput.addEventListener('input', draw);

        // Trigger Image Switch
        function switchImage() {
            if (images.length <= 1) return;
            if (isTransitioning) return; // Prevent double trigger
            
            nextImageIndex = (currentImageIndex + 1) % images.length;
            isTransitioning = true;
            transitionProgress = 0;
        }

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && isRecording) {
                e.preventDefault(); // Prevent scroll
                switchImage();
            }
        });
        
        canvas.addEventListener('click', () => {
             if(isRecording) switchImage();
        });


        function checkReady() {
            if (images.length > 0 && audioBuffer) {
                recordBtn.disabled = false;
                statusText.innerText = "æº–å‚™å®Œäº†";
            }
        }

        function draw() {
            // Clear
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (images.length > 0) {
                const imgCurrent = images[currentImageIndex];
                const imgNext = images[nextImageIndex];

                // Draw Current Image
                drawImageCover(ctx, imgCurrent, 1);

                // Handle Transition
                if (isTransitioning) {
                    transitionProgress += 0.02; // Transition speed
                    
                    // Draw Next Image on top with opacity
                    ctx.globalAlpha = transitionProgress;
                    drawImageCover(ctx, imgNext, 1);
                    ctx.globalAlpha = 1.0;

                    if (transitionProgress >= 1) {
                        isTransitioning = false;
                        currentImageIndex = nextImageIndex;
                        transitionProgress = 0;
                        updateThumbnails();
                    }
                }
            } else {
                // Default background
                const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
                grad.addColorStop(0, "#2c3e50");
                grad.addColorStop(1, "#3498db");
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Title Layer
            const text = titleInput.value;
            if (text) {
                ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                ctx.fillRect(0, canvas.height - 200, canvas.width, 200);
                
                ctx.fillStyle = "white";
                ctx.font = `bold ${fontSizeInput.value}px sans-serif`;
                ctx.textAlign = "center";
                ctx.shadowColor = "rgba(0,0,0,0.8)";
                ctx.shadowBlur = 10;
                ctx.fillText(text, canvas.width / 2, canvas.height - 80);
                ctx.shadowBlur = 0;
            }
        }

        function drawImageCover(ctx, img, alpha) {
             const scale = Math.max(canvas.width / img.width, canvas.height / img.height);
             const x = (canvas.width / 2) - (img.width / 2) * scale;
             const y = (canvas.height / 2) - (img.height / 2) * scale;
             ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
        }

        function updateThumbnails() {
            const thumbs = imageListContainer.children;
            for(let i=0; i<thumbs.length; i++) {
                thumbs[i].style.borderColor = (i === currentImageIndex) ? "#3498db" : "transparent";
                thumbs[i].style.opacity = (i === currentImageIndex) ? "1" : "0.6";
            }
        }

        recordBtn.addEventListener('click', () => {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        });

        function startRecording() {
            if (images.length === 0 || !audioBuffer) return;
            
            isRecording = true;
            recordBtn.innerText = "éŒ²ç”»ä¸­... (ã‚¯ãƒªãƒƒã‚¯/SBã‚­ãƒ¼ã§ç”»åƒåˆ‡æ›¿)";
            recordBtn.classList.add('recording');
            recordedChunks = [];

            // Audio Setup
            sourceNode = audioContext.createBufferSource();
            sourceNode.buffer = audioBuffer;
            
            destNode = audioContext.createMediaStreamDestination();
            sourceNode.connect(destNode);
            sourceNode.connect(audioContext.destination);

            const canvasStream = canvas.captureStream(30);
            const combinedStream = new MediaStream([
                ...canvasStream.getVideoTracks(),
                ...destNode.stream.getAudioTracks()
            ]);

            const options = { mimeType: 'video/webm; codecs=vp9' };
            try {
                mediaRecorder = new MediaRecorder(combinedStream, options);
            } catch (e) {
                mediaRecorder = new MediaRecorder(combinedStream);
            }

            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) recordedChunks.push(e.data);
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `video_${Date.now()}.webm`;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                }, 100);
                statusText.innerText = "ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†";
                resetFromRecording();
            };

            mediaRecorder.start();
            sourceNode.start(0);

            sourceNode.onended = () => {
                if (isRecording) stopRecording();
            };
            
            function loop() {
                if(!isRecording) return;
                draw(); // Continually redraw for fade effects
                // Visualizer/Progress
                const elapsed = audioContext.currentTime; 
                // Note: currentTime isn't reset per source start strictly, but accurate enough for simple bar
                // Better to track start time locally
                
                animationId = requestAnimationFrame(loop);
            }
            loop();
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            if (sourceNode) {
                sourceNode.stop();
            }
        }

        function resetFromRecording() {
            isRecording = false;
            recordBtn.innerText = "éŒ²ç”»é–‹å§‹ (å†ç”Ÿ)";
            recordBtn.classList.remove('recording');
            cancelAnimationFrame(animationId);
            draw();
        }
    </script>
</body>
</html>
